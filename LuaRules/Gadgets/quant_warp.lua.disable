
function gadget:GetInfo()
  return {
    name      = "TimeWarp",
    desc      = "Gives a unit the ability to jump back to its location a few seconds before.",
    author    = "quantum",
    date      = "April 2011",
    license   = "GNU GPL, v2 or later",
    layer     = -10,
    enabled   = false,  --  loaded by default?
  }
end



--[[
 todo: 
  * spawnkill unit at previous position
  * display reload time in the healthbar widget
 ]]

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

include "LuaRules/Configs/customcmds.h.lua"

local warpTime = 30 * 10 -- in game frames
local reloadTime = 30 * 15  -- in game frames
local rewindSpeed = 5
local unitState = {normal = 1, warping = 2}

if reloadTime < warpTime then
  error "reloadTime must be larger than warpTime"
end


local function getUnitState(unitID)
  return Spring.GetUnitRulesParam(unitID, "timewarp_state")
end



if gadgetHandler:IsSyncedCode() then
--------------------------------------------------------------------------------
-- SYNCED
--------------------------------------------------------------------------------

local unitPositionHistories = {}
local lastWarpTimes = {}
local coroutines  = {}

local timeWarpCmdDesc = {
  id      = CMD_TIMEWARP,
  type    = CMDTYPE.ICON,
  name    = 'Timewarp',
  action  = 'timewarp',
  tooltip = 'Jump to previous location',
}


local function setUnitState(unitID, state)
  Spring.SetUnitRulesParam(unitID, "timewarp_state", state)
end


local function reloadQueue(unitID, queue, cmdTag)
  if (not queue) then
    return
  end

    local re = Spring.GetUnitStates(unitID)["repeat"]
        local storeParams
  --// remove finished command
        local start = 1
        if (queue[1])and(cmdTag == queue[1].tag) then
                start = 2 
                 if re then
                        storeParams = queue[1].params
                end
        end

  Spring.GiveOrderToUnit(unitID, CMD.STOP, {}, {})
  for i=start,#queue do
    local cmd = queue[i]
    local cmdOpt = cmd.options
    local opts = {"shift"} -- appending
    if (cmdOpt.alt)   then opts[#opts+1] = "alt"   end
    if (cmdOpt.ctrl)  then opts[#opts+1] = "ctrl"  end
    if (cmdOpt.right) then opts[#opts+1] = "right" end
    Spring.GiveOrderToUnit(unitID, cmd.id, cmd.params, opts)
  end
  
  if re and start == 2 then
    Spring.GiveOrderToUnit(unitID, CMD.TIMEWARP, {}, {"shift"})
  end  
end


local function triggerUnsyncedEvent(eventArgs)
  _G.eventArgs = eventArgs
  SendToUnsynced("timeWarpEvent")
  _G.eventArgs = nil
end


local function enableTimeWarpAbility(unitID)
  Spring.InsertUnitCmdDesc(unitID, 500, timeWarpCmdDesc)
  unitPositionHistories[unitID] = {}
  lastWarpTimes[unitID] = Spring.GetGameFrame()
  triggerUnsyncedEvent {event = "addUnit", unitID = unitID}
  setUnitState(unitID, unitState.normal)
end


local function startCoroutine(fn)
  coroutines[#coroutines + 1] = coroutine.create(fn)
end


local function recordUnitPosition(unitID)
  local x, y, z = Spring.GetUnitPosition(unitID)
  local heading = Spring.GetUnitHeading(unitID)
  return {x, y, z, heading}
end


local function restoreUnitPosition(unitID, position)
  Spring.MoveCtrl.SetPosition(unitID, position[1], position[2], position[3])
  Spring.MoveCtrl.SetHeading(unitID, position[4])
end


local function warp(unitID)


  setUnitState(unitID, unitState.warping)
  Spring.MoveCtrl.Enable(unitID)
  Spring.MoveCtrl.SetLeaveTracks(unitID, false)
  
  
  local startFrame = Spring.GetGameFrame() - 1
  Spring.SetUnitRulesParam(unitID, "timewarp__startframe", startFrame)
  local positionHistory = unitPositionHistories[unitID]
  
  startCoroutine(function()
    -- burnteal
    -- warp
    for frame = startFrame, startFrame - warpTime, -rewindSpeed do
      restoreUnitPosition(unitID, positionHistory[frame])
      coroutine.yield() -- wait for the next game frame
      if not Spring.ValidUnitID(unitID) then
        return -- unit is dead, give up
      end
    end
    
    setUnitState(unitID, unitState.normal)
    local oldQueue = Spring.GetCommandQueue(unitID)
    reloadQueue(unitID, oldQueue)
    Spring.MoveCtrl.Disable(unitID)
    Spring.MoveCtrl.SetLeaveTracks(unitID, true)    
    lastWarpTimes[unitID] = Spring.GetGameFrame()
  end)
end


local function tryStartWarp(unitID)
  local gameFrame = Spring.GetGameFrame()
  if getUnitState(unitID) == unitState.normal and 
    gameFrame - lastWarpTimes[unitID] > reloadTime then
    warp(unitID)
  end
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


local function updateCoroutines() 
  local newCoroutines = {} 
  for i=1, #coroutines do 
    local co = coroutines[i] 
    if coroutine.status(co) ~= "dead" then 
      newCoroutines[#newCoroutines + 1] = co 
    end 
  end 
  coroutines = newCoroutines 
  for i=1, #coroutines do 
    local success, err = coroutine.resume(coroutines[i])
    if not success then
      Spring.Echo(err)
    end
  end
end


function gadget:Initialize()
  gadgetHandler:RegisterCMDID(CMD_TIMEWARP)
  for _, unitID in ipairs(Spring.GetAllUnits()) do
                gadget:UnitCreated(unitID, Spring.GetUnitDefID(unitID))
        end
end


function gadget:UnitDestroyed(unitID)
        reloads[unitID] = nil
  unitPositionHistories[unitID] = nil
end


function gadget:UnitCreated(unitID, unitDefID)
  enableTimeWarpAbility(unitID)
end


function gadget:Shutdown()
        for _, unitID in ipairs(Spring.GetAllUnits()) do
    local cmdDescID = Spring.FindUnitCmdDesc(unitID, CMD_TIMEWARP)
    if cmdDescID then
      Spring.RemoveUnitCmdDesc(unitID, cmdDescID)
    end
  end
end


function gadget:GameFrame(n)

  for unitID, positionHistory in pairs(unitPositionHistories) do
    if getUnitState(unitID) == unitState.normal and Spring.ValidUnitID(unitID) then
      unitPositionHistories[unitID][n] = recordUnitPosition(unitID)
      positionHistory[n - warpTime - 1] = nil -- discard unneeded position
    end
  end
  triggerUnsyncedEvent {event = "gameFrame"}
  updateCoroutines() 
end



function gadget:CommandFallback(unitID, unitDefID, teamID, cmdID, cmdParams, cmdOptions)
  if cmdID == CMD_TIMEWARP then
    tryStartWarp(unitID)    
    return true, true
  end
  return false
end

else
--------------------------------------------------------------------------------
-- UNSYNCED
--------------------------------------------------------------------------------


local function line(a, b, c, x, y, z)
  gl.Vertex(a, b, c)
  gl.Vertex(x, y, z)
end


local function drawLine(x1, y1, z1, x2, y2, z2)
  gl.BeginEnd(GL.LINES, line, x1, y1, z1, x2, y2, z2)
end


local function copyTable(original)   -- Warning: circular table references lead to an infinite loop.
        local copy = {}                   
        for key, value in pairs(original) do
                if type(value) == "table" then
                        copy[key] = copyTable(value)
                else
                        copy[key] = value
                end
        end
        return copy
end


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

local unitPositionHistories = {}


local function addUnit(eventArgs)
  unitPositionHistories[eventArgs.unitID] = {}
end


local function gameFrame()
  local n = Spring.GetGameFrame()
  for unitID, positionHistory in pairs(unitPositionHistories) do
    if Spring.ValidUnitID(unitID) then
      local x, y, z = Spring.GetUnitPosition(unitID)
      local dx, dy, dz = Spring.GetUnitDirection(unitID)
      local heading = - math.atan2(dz, dx) / 2 / math.pi * 360 + 90
      unitPositionHistories[unitID][n] = {x, y, z, heading} -- record current position
      -- positionHistory[n - warpTime - 1] = nil -- discard unneeded position
      
      if getUnitState(unitID) == unitState.warping then
      end
      
    end
  end
end


function handleEvent()
  local eventArgs = {}
  for key, value in spairs(SYNCED.eventArgs) do
    if type(value) == "table" then
      eventArgs[key] = copyTable(value)
    else
      eventArgs[key] = value
    end 
  end
  if eventArgs.event == "addUnit" then
    addUnit(eventArgs)
  elseif eventArgs.event == "gameFrame" then
    gameFrame()
  end
end



function gadget:Initialize()
  gadgetHandler:AddSyncAction("timeWarpEvent", handleEvent)
  for _, unitID in ipairs(Spring.GetAllUnits()) do
    addUnit{unitID = unitID}
  end
end

---[[

local trailLength = 30 * 0.6 -- in game frames
local trailDensity = 1 -- higher is less dense

function gadget:DrawWorld()
  for unitID, positionHistory in pairs(unitPositionHistories) do    
    local unitDefID = Spring.GetUnitDefID(unitID)
    local now =Spring.GetGameFrame() - 1
    local warpStartFrame = Spring.GetUnitRulesParam(unitID, "timewarp__startframe")
    if warpStartFrame then
      local warpEndFrame = warpStartFrame + warpTime 
      local startTrail = math.max(now - trailLength, warpStartFrame) -- no earlier than start of warp
      local endTrail = math.min(now, warpEndFrame) -- no later than end of warp
      if startTrail < endTrail then
        local state = getUnitState(unitID)
        local is3do =  UnitDefs[unitDefID].model and UnitDefs[unitDefID].model.type == "3do"
        gl.Blending(false)
        gl.DepthTest(true)
        gl.DepthMask(true)
        gl.DepthTest(GL.LEQUAL)
        if is3do then
           gl.Texture(0, "$units")      
        else
          gl.Texture(0, "%"..unitDefID..":0")
        end
        for drawFrame = startTrail, endTrail, trailDensity do
          local drawLocation = positionHistory[drawFrame]
          if drawLocation then
            gl.PushMatrix()
            gl.Translate(drawLocation[1], drawLocation[2], drawLocation[3])
            gl.Rotate(drawLocation[4], 0, 1, 0)
            gl.Color(1, 1, 1, 0.2)
            gl.UnitRaw(unitID, true)
            gl.PopMatrix()
          end
        end
      end
    end
  end
end
--]]

end
